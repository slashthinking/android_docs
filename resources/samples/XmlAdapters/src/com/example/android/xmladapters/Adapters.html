<!DOCTYPE html>








































































<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<link rel="shortcut icon" type="image/x-icon" href="../../../../../../../../favicon.ico" />
<title>Adapters.java | Android Developers</title>

<!-- STYLESHEETS -->
<link rel="stylesheet"
href="http://fonts.googleapis.com/css?family=Roboto:regular,medium,thin,italic,mediumitalic,bold" title="roboto">
<link href="../../../../../../../../assets/css/default.css" rel="stylesheet" type="text/css">



<!-- JAVASCRIPT -->
<script src="http://www.google.com/jsapi" type="text/javascript"></script>
<script src="../../../../../../../../assets/js/global-libraries-combined.js" type="text/javascript"></script>
<script type="text/javascript">
  var toRoot = "../../../../../../../../";
</script>
<script src="../../../../../../../../assets/js/docs.js" type="text/javascript"></script>
<script src="../../../../../../../../navtree_data.js" type="text/javascript"></script>

</head>

    <!-- Header -->
    <div id="header">
        <div class="wrap" id="header-wrap">
          <div class="col-3 logo">
          <a href="../../../../../../../../index.html">
            <img src="../../../../../../../../assets/images/dac_logo.png" width="123" height="25" alt="Android Developers" />
          </a>
          <div class="btn-quicknav" id="btn-quicknav">
          	<a href="#" class="arrow-inactive">Quicknav</a>
			      <a href="#" class="arrow-active">Quicknav</a>
          </div>
          </div>
            <ul class="nav-x col-9">
                <li class="design">
                  <a href="../../../../../../../../design/index.html" 
                  zh-TW-lang="設計"
                  zh-CN-lang="设计"
                  ru-lang="Проектирование"
                  ko-lang="디자인"
                  ja-lang="設計"
                  es-lang="Diseñar"               
                  >设计</a></li>
                <li class="develop"><a href="../../../../../../../../develop/index.html" 
                  zh-TW-lang="開發"
                  zh-CN-lang="开发"
                  ru-lang="Разработка"
                  ko-lang="개발"
                  ja-lang="開発"
                  es-lang="Desarrollar"               
                  >开发</a></li>
                <li class="distribute last"><a href="../../../../../../../../distribute/index.html" 
                  zh-TW-lang="發佈"
                  zh-CN-lang="分发"
                  ru-lang="Распространение"
                  ko-lang="배포"
                  ja-lang="配布"
                  es-lang="Distribuir"               
                  >分发</a></li>
            </ul>
            
            <!-- New Search -->
            <div class="menu-container">
            <div class="moremenu">
    <div id="more-btn"></div>
  </div>
  <div class="morehover" id="moremenu">
    <div class="top"></div>
    <div class="mid">
      <div class="header">Links</div>
      <ul>
        <li><a href="https://play.google.com/apps/publish/">Google Play Developer Console</a></li>
        <li><a href="http://android-developers.blogspot.com/">Android Developers Blog</a></li>
        <li><a href="../../../../../../../../about/index.html">About Android</a></li>
      </ul>
      <div class="header">Android Sites</div>
      <ul>
        <li><a href="http://www.android.com">Android.com</a></li>
        <li class="active"><a>Android Developers</a></li>
        <li><a href="http://source.android.com">Android Open Source Project</a></li>
      </ul>
      <!-- <div class="header">Support</div>
      <ul>
        <li><a href="../../../../../../../../support.html">Developer Support</a></li>
      </ul> -->
      <div class="header">Languages</div>
        <div id="language" class="locales">
          <select name="language" onChange="changeLangPref(this.value, true)">
              <option value="en">English</option>
              <option value="es">Español</option>
              <option value="ja">日本語</option>
              <option value="ko">한국어</option>
              <option value="ru">Русский</option>
              <option value="zh-CN">中文 (中国)</option>
              <option value="zh-TW">中文 (台灣)</option>
          </select>
        </div>
      <script type="text/javascript">
        <!--  
        loadLangPref();  
          //-->
      </script>
      <br class="clearfix" />
    </div>
    <div class="bottom"></div>
  </div>
  <div class="search" id="search-container">
    <div class="search-inner">
      <div id="search-btn"></div>
      <div class="left"></div>
      <form onsubmit="return submit_search()">
        <input id="search_autocomplete" type="text" value="" autocomplete="off" name="q"
onfocus="search_focus_changed(this, true)" onblur="search_focus_changed(this, false)"
onkeydown="return search_changed(event, true, '../../../../../../../../')" 
onkeyup="return search_changed(event, false, '../../../../../../../../')" />
      </form>
      <div class="right"></div>
        <a class="close hide">close</a>
        <div class="left"></div>
        <div class="right"></div>
    </div>
  </div>
  <div id="search_filtered_wrapper">
    <div id="search_filtered_div" class="no-display">
        <ul id="search_filtered">
        </ul>
    </div>
  </div>
  
  </div>
  <!-- /New Search>
          
          
          <!-- Expanded quicknav -->
           <div id="quicknav" class="col-9">
                <ul>
                    <li class="design">
                      <ul>
                        <li><a href="../../../../../../../../design/index.html">开始</a></li>
                        <li><a href="../../../../../../../../design/style/index.html">Style</a></li>
                        <li><a href="../../../../../../../../design/patterns/index.html">Patterns</a></li>
                        <li><a href="../../../../../../../../design/building-blocks/index.html">Building Blocks</a></li>
                        <li><a href="../../../../../../../../design/downloads/index.html">Downloads</a></li>
                        <li><a href="../../../../../../../../design/videos/index.html">Videos</a></li>
                      </ul>
                    </li>
                    <li class="develop">
                      <ul>
                        <li><a href="../../../../../../../../training/index.html"
                          zh-TW-lang="訓練課程"
                          zh-CN-lang="培训"
                          ru-lang="Курсы"
                          ko-lang="교육"
                          ja-lang="トレーニング"
                          es-lang="Capacitación"               
                          >训练</a></li>
                        <li><a href="../../../../../../../../guide/components/index.html"
                          zh-TW-lang="API 指南"
                          zh-CN-lang="API 指南"
                          ru-lang="Руководства по API"
                          ko-lang="API 가이드"
                          ja-lang="API ガイド"
                          es-lang="Guías de la API"               
                          >API 指南</a></li>
                        <li><a href="../../../../../../../../reference/packages.html"
                          zh-TW-lang="參考資源"
                          zh-CN-lang="参考"
                          ru-lang="Справочник"
                          ko-lang="참조문서"
                          ja-lang="リファレンス"
                          es-lang="Referencia"               
                          >参考</a></li>
                        <li><a href="../../../../../../../../tools/index.html"
                          zh-TW-lang="相關工具"
                          zh-CN-lang="工具"
                          ru-lang="Инструменты"
                          ko-lang="도구"
                          ja-lang="ツール"
                          es-lang="Herramientas"               
                          >工具</a>
                          <ul><li><a href="../../../../../../../../sdk/index.html">Get the
SDK</a></li></ul>
                        </li>
                      </ul>
                    </li>
                    <li class="distribute last">
                      <ul>
                        <li><a href="../../../../../../../../distribute/index.html">Google Play</a></li>
                        <li><a href="../../../../../../../../distribute/googleplay/publish/index.html">Publishing</a></li>
                        <li><a href="../../../../../../../../distribute/googleplay/promote/index.html">Promoting</a></li>
                        <li><a href="../../../../../../../../distribute/googleplay/quality/index.html">App Quality</a></li>
                        <li><a href="../../../../../../../../distribute/googleplay/spotlight/index.html">Spotlight</a></li>
                        <li><a href="../../../../../../../../distribute/open.html">Open Distribution</a></li>
                      </ul>
                    </li>
                </ul>
          </div>
          <!-- /Expanded quicknav -->
        </div>
    </div>
    <!-- /Header -->
    
    
  <div id="searchResults" class="wrap" style="display:none;">
          <h2 id="searchTitle">Results</h2>
          <div id="leftSearchControl" class="search-control">Loading...</div>
  </div>
    
    
    

  

  <div class="wrap clearfix" id="body-content">
    <div class="col-4" id="side-nav" itemscope itemtype="http://schema.org/SiteNavigationElement">
      <div id="devdoc-nav">
<a class="totop" href="#top" data-g-event="left-nav-top">to top</a>
      <div id="api-nav-header">
        <div id="api-level-toggle">
          <label for="apiLevelCheckbox" class="disabled">API level: </label>
          <div class="select-wrapper">
            <select id="apiLevelSelector">
              <!-- option elements added by buildApiLevelSelector() -->
            </select>
          </div>
        </div><!-- end toggle -->
        <div id="api-nav-title">Android APIs</div>
        </div><!-- end nav header -->
      <script>
        var SINCE_DATA = [  ];
        buildApiLevelSelector();
      </script>
                  
      <div id="swapper">
        <div id="nav-panels">
          <div id="resize-packages-nav">
            <div id="packages-nav" class="scroll-pane">

              <ul>
              	
              </ul><br/>

            </div> <!-- end packages-nav -->
          </div> <!-- end resize-packages -->
          <div id="classes-nav" class="scroll-pane">



              <p style="padding:10px">Select a package to view its members</p><br/>
        

          </div><!-- end classes -->
        </div><!-- end nav-panels -->
        <div id="nav-tree" style="display:none" class="scroll-pane">
          <div id="tree-list"></div>
        </div><!-- end nav-tree -->
      </div><!-- end swapper -->
      <div id="nav-swap">
      <a class="fullscreen">fullscreen</a>
      <a href='#' onclick='swapNav();return false;'><span id='tree-link'>Use Tree Navigation</span><span id='panel-link' style='display:none'>Use Panel Navigation</span></a>
      </div>
    </div> <!-- end devdoc-nav -->
    </div> <!-- end side-nav -->
    <script type="text/javascript">
      // init fullscreen based on user pref
      var fullscreen = readCookie("fullscreen");
      if (fullscreen != 0) {
        if (fullscreen == "false") {
          toggleFullscreen(false);
        } else {
          toggleFullscreen(true);
        }
      }
      // init nav version for mobile
      if (isMobile) {
        swapNav(); // tree view should be used on mobile
        $('#nav-swap').hide();
      } else {
        chooseDefaultNav();
        if ($("#nav-tree").is(':visible')) {
          init_default_navtree("../../../../../../../../");
        }
      }
      // scroll the selected page into view
      $(document).ready(function() {
        scrollIntoView("packages-nav");
        scrollIntoView("classes-nav");
        });
    </script>
    <script>
      $(document).ready(function() {
        changeDocLang(getLangPref());
        });
    </script>


<body class="gc-documentation">


<a name="top"></a>
<div class="g-unit" id="doc-content">
 <div id="jd-header" class="guide-header">
  <span class="crumb">&nbsp;</span>
  <h1>Adapters.java</h1>
 </div>

<div id="jd-content">
<p><a href="index.html">&larr; Back</a></p>

<p>The file containing the source code shown below is located in the corresponding directory in <code>&lt;sdk&gt;/samples/android-&lt;version&gt;/...</code></p>

<!-- begin file contents -->
<pre>/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.example.android.xmladapters;

import android.app.Activity;
import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.content.res.XmlResourceParser;
import android.database.Cursor;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.os.AsyncTask;
import android.util.AttributeSet;
import android.util.Xml;
import android.view.View;
import android.widget.BaseAdapter;
import android.widget.CursorAdapter;
import android.widget.ImageView;
import android.widget.SimpleCursorAdapter;
import android.widget.TextView;

import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.HashMap;

/**
 * &lt;p&gt;This class can be used to load {@link android.widget.Adapter adapters} defined in
 * XML resources. XML-defined adapters can be used to easily create adapters in your
 * own application or to pass adapters to other processes.&lt;/p&gt;
 * 
 * &lt;h2&gt;Types of adapters&lt;/h2&gt;
 * &lt;p&gt;Adapters defined using XML resources can only be one of the following supported
 * types. Arbitrary adapters are not supported to guarantee the safety of the loaded
 * code when adapters are loaded across packages.&lt;/p&gt;
 * &lt;ul&gt;
 *  &lt;li&gt;&lt;a href="#xml-cursor-adapter"&gt;Cursor adapter&lt;/a&gt;: a cursor adapter can be used
 *  to display the content of a cursor, most often coming from a content provider&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;The complete XML format definition of each adapter type is available below.&lt;/p&gt;
 * 
 * &lt;a name="xml-cursor-adapter"&gt;&lt;/a&gt;
 * &lt;h2&gt;Cursor adapter&lt;/h2&gt;
 * &lt;p&gt;A cursor adapter XML definition starts with the
 * &lt;a href="#xml-cursor-adapter-tag"&gt;&lt;code&gt;&amp;lt;cursor-adapter /&amp;gt;&lt;/code&gt;&lt;/a&gt;
 * tag and may contain one or more instances of the following tags:&lt;/p&gt;
 * &lt;ul&gt;
 *  &lt;li&gt;&lt;a href="#xml-cursor-adapter-select-tag"&gt;&lt;code&gt;&amp;lt;select /&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
 *  &lt;li&gt;&lt;a href="#xml-cursor-adapter-bind-tag"&gt;&lt;code&gt;&amp;lt;bind /&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;a name="xml-cursor-adapter-tag"&gt;&lt;/a&gt;
 * &lt;h3&gt;&amp;lt;cursor-adapter /&amp;gt;&lt;/h3&gt;
 * &lt;p&gt;The &lt;code&gt;&amp;lt;cursor-adapter /&amp;gt;&lt;/code&gt; element defines the beginning of the
 * document and supports the following attributes:&lt;/p&gt;
 * &lt;ul&gt;
 *  &lt;li&gt;&lt;code&gt;android:layout&lt;/code&gt;: Reference to the XML layout to be inflated for
 *  each item of the adapter. This attribute is mandatory.&lt;/li&gt;
 *  &lt;li&gt;&lt;code&gt;android:selection&lt;/code&gt;: Selection expression, used when the
 *  &lt;code&gt;android:uri&lt;/code&gt; attribute is defined or when the adapter is loaded with
 *  {@link Adapters#loadCursorAdapter(android.content.Context, int, String, Object[])}.
 *  This attribute is optional.&lt;/li&gt;
 *  &lt;li&gt;&lt;code&gt;android:sortOrder&lt;/code&gt;: Sort expression, used when the
 *  &lt;code&gt;android:uri&lt;/code&gt; attribute is defined or when the adapter is loaded with
 *  {@link Adapters#loadCursorAdapter(android.content.Context, int, String, Object[])}.
 *  This attribute is optional.&lt;/li&gt;
 *  &lt;li&gt;&lt;code&gt;android:uri&lt;/code&gt;: URI of the content provider to query to retrieve a cursor.
 *  Specifying this attribute is equivalent to calling
 *  {@link Adapters#loadCursorAdapter(android.content.Context, int, String, Object[])}.
 *  If you call this method, the value of the XML attribute is ignored. This attribute is
 *  optional.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;In addition, you can specify one or more instances of
 * &lt;a href="#xml-cursor-adapter-select-tag"&gt;&lt;code&gt;&amp;lt;select /&amp;gt;&lt;/code&gt;&lt;/a&gt; and
 * &lt;a href="#xml-cursor-adapter-bind-tag"&gt;&lt;code&gt;&amp;lt;bind /&amp;gt;&lt;/code&gt;&lt;/a&gt; tags as children
 * of &lt;code&gt;&amp;lt;cursor-adapter /&amp;gt;&lt;/code&gt;.&lt;/p&gt;
 * 
 * &lt;a name="xml-cursor-adapter-select-tag"&gt;&lt;/a&gt;
 * &lt;h3&gt;&amp;lt;select /&amp;gt;&lt;/h3&gt;
 * &lt;p&gt;The &lt;code&gt;&amp;lt;select /&amp;gt;&lt;/code&gt; tag is used to select columns from the cursor
 * when doing the query. This can be very useful when using transformations in the
 * &lt;code&gt;&amp;lt;bind /&amp;gt;&lt;/code&gt; elements. It can also be very useful if you are providing
 * your own &lt;a href="#xml-cursor-adapter-bind-data-types"&gt;binder&lt;/a&gt; or
 * &lt;a href="#xml-cursor-adapter-bind-data-types"&gt;transformation&lt;/a&gt; classes.
 * &lt;code&gt;&amp;lt;select /&amp;gt;&lt;/code&gt; elements are ignored if you supply the cursor yourself.&lt;/p&gt;
 * &lt;p&gt;The &lt;code&gt;&amp;lt;select /&amp;gt;&lt;/code&gt; supports the following attributes:&lt;/p&gt;
 * &lt;ul&gt;
 *  &lt;li&gt;&lt;code&gt;android:column&lt;/code&gt;: Name of the column to select in the cursor during the
 *  query operation&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The column named &lt;code&gt;_id&lt;/code&gt; is always implicitly
 * selected.&lt;/p&gt;
 * 
 * &lt;a name="xml-cursor-adapter-bind-tag"&gt;&lt;/a&gt;
 * &lt;h3&gt;&amp;lt;bind /&amp;gt;&lt;/h3&gt;
 * &lt;p&gt;The &lt;code&gt;&amp;lt;bind /&amp;gt;&lt;/code&gt; tag is used to bind a column from the cursor to
 * a {@link android.view.View}. A column bound using this tag is automatically selected
 * during the query and a matching
 * &lt;a href="#xml-cursor-adapter-select-tag"&gt;&lt;code&gt;&amp;lt;select /&amp;gt;&lt;/code&gt; tag is therefore
 * not required.&lt;/p&gt;
 * 
 * &lt;p&gt;Each binding is declared as a one to one matching but
 * custom binder classes or special
 * &lt;a href="#xml-cursor-adapter-bind-data-transformation"&gt;data transformations&lt;/a&gt; can
 * allow you to bind several columns to a single view. In this case you must use the
 * &lt;a href="#xml-cursor-adapter-select-tag"&gt;&lt;code&gt;&amp;lt;select /&amp;gt;&lt;/code&gt; tag to make
 * sure any required column is part of the query.&lt;/p&gt;
 * 
 * &lt;p&gt;The &lt;code&gt;&amp;lt;bind /&amp;gt;&lt;/code&gt; tag supports the following attributes:&lt;/p&gt;
 * &lt;ul&gt;
 *  &lt;li&gt;&lt;code&gt;android:from&lt;/code&gt;: The name of the column to bind from.
 *  This attribute is mandatory. Note that &lt;code&gt;@&lt;/code&gt; which are not used to reference resources
 *  should be backslash protected as in &lt;code&gt;\@&lt;/code&gt;.&lt;/li&gt;
 *  &lt;li&gt;&lt;code&gt;android:to&lt;/code&gt;: The id of the view to bind to. This attribute is mandatory.&lt;/li&gt;
 *  &lt;li&gt;&lt;code&gt;android:as&lt;/code&gt;: The &lt;a href="#xml-cursor-adapter-bind-data-types"&gt;data type&lt;/a&gt;
 *  of the binding. This attribute is mandatory.&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;In addition, a &lt;code&gt;&amp;lt;bind /&amp;gt;&lt;/code&gt; can contain zero or more instances of
 * &lt;a href="#xml-cursor-adapter-bind-data-transformation"&gt;data transformations&lt;/a&gt; children
 * tags.&lt;/p&gt;
 *
 * &lt;a name="xml-cursor-adapter-bind-data-types"&gt;&lt;/a&gt;
 * &lt;h4&gt;Binding data types&lt;/h4&gt;
 * &lt;p&gt;For a binding to occur the data type of the bound column/view pair must be specified.
 * The following data types are currently supported:&lt;/p&gt;
 * &lt;ul&gt;
 *  &lt;li&gt;&lt;code&gt;string&lt;/code&gt;: The content of the column is interpreted as a string and must be
 *  bound to a {@link android.widget.TextView}&lt;/li&gt;
 *  &lt;li&gt;&lt;code&gt;image&lt;/code&gt;: The content of the column is interpreted as a blob describing an
 *  image and must be bound to an {@link android.widget.ImageView}&lt;/li&gt;
 *  &lt;li&gt;&lt;code&gt;image-uri&lt;/code&gt;: The content of the column is interpreted as a URI to an image
 *  and must be bound to an {@link android.widget.ImageView}&lt;/li&gt;
 *  &lt;li&gt;&lt;code&gt;drawable&lt;/code&gt;: The content of the column is interpreted as a resource id to a
 *  drawable and must be bound to an {@link android.widget.ImageView}&lt;/li&gt;
 *  &lt;li&gt;&lt;code&gt;tag&lt;/code&gt;: The content of the column is interpreted as a string and will be set as
 *  the tag (using {@link View#setTag(Object)} of the associated View. This can be used to
 *  associate meta-data to your view, that can be used for instance by a listener.&lt;/li&gt;
 *  &lt;li&gt;A fully qualified class name: The name of a class corresponding to an implementation of
 *  {@link Adapters.CursorBinder}. Cursor binders can be used to provide
 *  bindings not supported by default. Custom binders cannot be used with
 *  {@link android.content.Context#isRestricted() restricted contexts}, for instance in an
 *  application widget&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;a name="xml-cursor-adapter-bind-transformation"&gt;&lt;/a&gt;
 * &lt;h4&gt;Binding transformations&lt;/h4&gt;
 * &lt;p&gt;When defining a data binding you can specify an optional transformation by using one
 * of the following tags as a child of a &lt;code&gt;&amp;lt;bind /&amp;gt;&lt;/code&gt; elements:&lt;/p&gt;
 * &lt;ul&gt;
 *  &lt;li&gt;&lt;code&gt;&amp;lt;map /&amp;gt;&lt;/code&gt;: Maps a constant string to a string or a resource. Use
 *  one instance of this tag per value you want to map&lt;/li&gt;
 *  &lt;li&gt;&lt;code&gt;&amp;lt;transform /&amp;gt;&lt;/code&gt;: Transforms a column's value using an expression
 *  or an instance of {@link Adapters.CursorTransformation}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;While several &lt;code&gt;&amp;lt;map /&amp;gt;&lt;/code&gt; tags can be used at the same time, you cannot
 * mix &lt;code&gt;&amp;lt;map /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;transform /&amp;gt;&lt;/code&gt; tags. If several
 * &lt;code&gt;&amp;lt;transform /&amp;gt;&lt;/code&gt; tags are specified, only the last one is retained.&lt;/p&gt;
 * 
 * &lt;a name="xml-cursor-adapter-bind-transformation-map" /&gt;
 * &lt;p&gt;&lt;strong&gt;&amp;lt;map /&amp;gt;&lt;/strong&gt;&lt;/p&gt;
 * &lt;p&gt;A map element simply specifies a value to match from and a value to match to. When
 * a column's value equals the value to match from, it is replaced with the value to match
 * to. The following attributes are supported:&lt;/p&gt;
 * &lt;ul&gt;
 *  &lt;li&gt;&lt;code&gt;android:fromValue&lt;/code&gt;: The value to match from. This attribute is mandatory&lt;/li&gt;
 *  &lt;li&gt;&lt;code&gt;android:toValue&lt;/code&gt;: The value to match to. This value can be either a string
 *  or a resource identifier. This value is interpreted as a resource identifier when the
 *  data binding is of type &lt;code&gt;drawable&lt;/code&gt;. This attribute is mandatory&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;a name="xml-cursor-adapter-bind-transformation-transform"&gt;&lt;/a&gt;
 * &lt;p&gt;&lt;strong&gt;&amp;lt;transform /&amp;gt;&lt;/strong&gt;&lt;/p&gt;
 * &lt;p&gt;A simple transform that occurs either by calling a specified class or by performing
 * simple text substitution. The following attributes are supported:&lt;/p&gt;
 * &lt;ul&gt;
 *  &lt;li&gt;&lt;code&gt;android:withExpression&lt;/code&gt;: The transformation expression. The expression is
 *  a string containing column names surrounded with curly braces { and }. During the
 *  transformation each column name is replaced by its value. All columns must have been
 *  selected in the query. An example of expression is &lt;code&gt;"First name: {first_name},
 *  last name: {last_name}"&lt;/code&gt;. This attribute is mandatory
 *  if &lt;code&gt;android:withClass&lt;/code&gt; is not specified and ignored if &lt;code&gt;android:withClass&lt;/code&gt;
 *  is specified&lt;/li&gt;
 *  &lt;li&gt;&lt;code&gt;android:withClass&lt;/code&gt;: A fully qualified class name corresponding to an
 *  implementation of {@link Adapters.CursorTransformation}. Custom
 *  transformations cannot be used with
 *  {@link android.content.Context#isRestricted() restricted contexts}, for instance in
 *  an app widget This attribute is mandatory if &lt;code&gt;android:withExpression&lt;/code&gt; is
 *  not specified&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;h3&gt;Example&lt;/h3&gt;
 * &lt;p&gt;The following example defines a cursor adapter that queries all the contacts with
 * a phone number using the contacts content provider. Each contact is displayed with
 * its display name, its favorite status and its photo. To display photos, a custom data
 * binder is declared:&lt;/p&gt;
 * 
 * &lt;pre class="prettyprint"&gt;
 * &amp;lt;cursor-adapter xmlns:android="http://schemas.android.com/apk/res/android"
 *     android:uri="content://com.android.contacts/contacts"
 *     android:selection="has_phone_number=1"
 *     android:layout="@layout/contact_item"&amp;gt;
 *
 *     &amp;lt;bind android:from="display_name" android:to="@id/name" android:as="string" /&amp;gt;
 *     &amp;lt;bind android:from="starred" android:to="@id/star" android:as="drawable"&amp;gt;
 *         &amp;lt;map android:fromValue="0" android:toValue="@android:drawable/star_big_off" /&amp;gt;
 *         &amp;lt;map android:fromValue="1" android:toValue="@android:drawable/star_big_on" /&amp;gt;
 *     &amp;lt;/bind&amp;gt;
 *     &amp;lt;bind android:from="_id" android:to="@id/name"
 *              android:as="com.google.android.test.adapters.ContactPhotoBinder" /&amp;gt;
 *
 * &amp;lt;/cursor-adapter&amp;gt;
 * &lt;/pre&gt;
 * 
 * &lt;h3&gt;Related APIs&lt;/h3&gt;
 * &lt;ul&gt;
 *  &lt;li&gt;{@link Adapters#loadAdapter(android.content.Context, int, Object[])}&lt;/li&gt;
 *  &lt;li&gt;{@link Adapters#loadCursorAdapter(android.content.Context, int, android.database.Cursor, Object[])}&lt;/li&gt;
 *  &lt;li&gt;{@link Adapters#loadCursorAdapter(android.content.Context, int, String, Object[])}&lt;/li&gt;
 *  &lt;li&gt;{@link Adapters.CursorBinder}&lt;/li&gt;
 *  &lt;li&gt;{@link Adapters.CursorTransformation}&lt;/li&gt;
 *  &lt;li&gt;{@link android.widget.CursorAdapter}&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * @see android.widget.Adapter
 * @see android.content.ContentProvider
 * 
 * attr ref android.R.styleable#CursorAdapter_layout
 * attr ref android.R.styleable#CursorAdapter_selection
 * attr ref android.R.styleable#CursorAdapter_sortOrder
 * attr ref android.R.styleable#CursorAdapter_uri
 * attr ref android.R.styleable#CursorAdapter_BindItem_as
 * attr ref android.R.styleable#CursorAdapter_BindItem_from
 * attr ref android.R.styleable#CursorAdapter_BindItem_to
 * attr ref android.R.styleable#CursorAdapter_MapItem_fromValue
 * attr ref android.R.styleable#CursorAdapter_MapItem_toValue
 * attr ref android.R.styleable#CursorAdapter_SelectItem_column
 * attr ref android.R.styleable#CursorAdapter_TransformItem_withClass
 * attr ref android.R.styleable#CursorAdapter_TransformItem_withExpression
 */
public class Adapters {
    private static final String ADAPTER_CURSOR = "cursor-adapter";

    /**
     * &lt;p&gt;Interface used to bind a {@link android.database.Cursor} column to a View. This
     * interface can be used to provide bindings for data types not supported by the
     * standard implementation of {@link Adapters}.&lt;/p&gt;
     * 
     * &lt;p&gt;A binder is provided with a cursor transformation which may or may not be used
     * to transform the value retrieved from the cursor. The transformation is guaranteed
     * to never be null so it's always safe to apply the transformation.&lt;/p&gt;
     * 
     * &lt;p&gt;The binder is associated with a Context but can be re-used with multiple cursors.
     * As such, the implementation should make no assumption about the Cursor in use.&lt;/p&gt;
     *
     * @see android.view.View 
     * @see android.database.Cursor
     * @see Adapters.CursorTransformation
     */
    public static abstract class CursorBinder {
        /**
         * &lt;p&gt;The context associated with this binder.&lt;/p&gt;
         */
        protected final Context mContext;

        /**
         * &lt;p&gt;The transformation associated with this binder. This transformation is never
         * null and may or may not be applied to the Cursor data during the
         * {@link #bind(android.view.View, android.database.Cursor, int)} operation.&lt;/p&gt;
         * 
         * @see #bind(android.view.View, android.database.Cursor, int) 
         */
        protected final CursorTransformation mTransformation;

        /**
         * &lt;p&gt;Creates a new Cursor binder.&lt;/p&gt; 
         * 
         * @param context The context associated with this binder.
         * @param transformation The transformation associated with this binder. This
         *        transformation may or may not be applied by the binder and is guaranteed
         *        to not be null.
         */
        public CursorBinder(Context context, CursorTransformation transformation) {
            mContext = context;
            mTransformation = transformation;
        }

        /**
         * &lt;p&gt;Binds the specified Cursor column to the supplied View. The binding operation
         * can query other Cursor columns as needed. During the binding operation, values
         * retrieved from the Cursor may or may not be transformed using this binder's
         * cursor transformation.&lt;/p&gt;
         * 
         * @param view The view to bind data to.
         * @param cursor The cursor to bind data from.
         * @param columnIndex The column index in the cursor where the data to bind resides.
         * 
         * @see #mTransformation
         * 
         * @return True if the column was successfully bound to the View, false otherwise.
         */
        public abstract boolean bind(View view, Cursor cursor, int columnIndex);
    }

    /**
     * &lt;p&gt;Interface used to transform data coming out of a {@link android.database.Cursor}
     * before it is bound to a {@link android.view.View}.&lt;/p&gt;
     * 
     * &lt;p&gt;Transformations are used to transform text-based data (in the form of a String),
     * or to transform data into a resource identifier. A default implementation is provided
     * to generate resource identifiers.&lt;/p&gt;
     * 
     * @see android.database.Cursor
     * @see Adapters.CursorBinder
     */
    public static abstract class CursorTransformation {
        /**
         * &lt;p&gt;The context associated with this transformation.&lt;/p&gt;
         */
        protected final Context mContext;

        /**
         * &lt;p&gt;Creates a new Cursor transformation.&lt;/p&gt;
         * 
         * @param context The context associated with this transformation.
         */
        public CursorTransformation(Context context) {
            mContext = context;
        }

        /**
         * &lt;p&gt;Transforms the specified Cursor column into a String. The transformation
         * can simply return the content of the column as a String (this is known
         * as the identity transformation) or manipulate the content. For instance,
         * a transformation can perform text substitutions or concatenate other
         * columns with the specified column.&lt;/p&gt;
         * 
         * @param cursor The cursor that contains the data to transform. 
         * @param columnIndex The index of the column to transform.
         * 
         * @return A String containing the transformed value of the column.
         */
        public abstract String transform(Cursor cursor, int columnIndex);

        /**
         * &lt;p&gt;Transforms the specified Cursor column into a resource identifier.
         * The default implementation simply interprets the content of the column
         * as an integer.&lt;/p&gt;
         * 
         * @param cursor The cursor that contains the data to transform. 
         * @param columnIndex The index of the column to transform.
         * 
         * @return A resource identifier.
         */
        public int transformToResource(Cursor cursor, int columnIndex) {
            return cursor.getInt(columnIndex);
        }
    }

    /**
     * &lt;p&gt;Loads the {@link android.widget.CursorAdapter} defined in the specified
     * XML resource. The content of the adapter is loaded from the content provider
     * identified by the supplied URI.&lt;/p&gt;
     * 
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If the supplied {@link android.content.Context} is
     * an {@link android.app.Activity}, the cursor returned by the content provider
     * will be automatically managed. Otherwise, you are responsible for managing the
     * cursor yourself.&lt;/p&gt;
     * 
     * &lt;p&gt;The format of the XML definition of the cursor adapter is documented at
     * the top of this page.&lt;/p&gt;
     * 
     * @param context The context to load the XML resource from.
     * @param id The identifier of the XML resource declaring the adapter.
     * @param uri The URI of the content provider.
     * @param parameters Optional parameters to pass to the CursorAdapter, used
     *        to substitute values in the selection expression.
     * 
     * @return A {@link android.widget.CursorAdapter}
     * 
     * @throws IllegalArgumentException If the XML resource does not contain
     *         a valid &amp;lt;cursor-adapter /&amp;gt; definition.
     * 
     * @see android.content.ContentProvider
     * @see android.widget.CursorAdapter
     * @see #loadAdapter(android.content.Context, int, Object[])
     */
    public static CursorAdapter loadCursorAdapter(Context context, int id, String uri,
            Object... parameters) {

        XmlCursorAdapter adapter = (XmlCursorAdapter) loadAdapter(context, id, ADAPTER_CURSOR,
                parameters);

        if (uri != null) {
            adapter.setUri(uri);
        }
        adapter.load();

        return adapter;
    }

    /**
     * &lt;p&gt;Loads the {@link android.widget.CursorAdapter} defined in the specified
     * XML resource. The content of the adapter is loaded from the specified cursor.
     * You are responsible for managing the supplied cursor.&lt;/p&gt;
     * 
     * &lt;p&gt;The format of the XML definition of the cursor adapter is documented at
     * the top of this page.&lt;/p&gt;
     * 
     * @param context The context to load the XML resource from.
     * @param id The identifier of the XML resource declaring the adapter.
     * @param cursor The cursor containing the data for the adapter.
     * @param parameters Optional parameters to pass to the CursorAdapter, used
     *        to substitute values in the selection expression.
     * 
     * @return A {@link android.widget.CursorAdapter}
     * 
     * @throws IllegalArgumentException If the XML resource does not contain
     *         a valid &amp;lt;cursor-adapter /&amp;gt; definition.
     * 
     * @see android.content.ContentProvider
     * @see android.widget.CursorAdapter
     * @see android.database.Cursor
     * @see #loadAdapter(android.content.Context, int, Object[])
     */
    public static CursorAdapter loadCursorAdapter(Context context, int id, Cursor cursor,
            Object... parameters) {

        XmlCursorAdapter adapter = (XmlCursorAdapter) loadAdapter(context, id, ADAPTER_CURSOR,
                parameters);

        if (cursor != null) {
            adapter.changeCursor(cursor);
        }

        return adapter;
    }

    /**
     * &lt;p&gt;Loads the adapter defined in the specified XML resource. The XML definition of
     * the adapter must follow the format definition of one of the supported adapter
     * types described at the top of this page.&lt;/p&gt;
     * 
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If the loaded adapter is a {@link android.widget.CursorAdapter}
     * and the supplied {@link android.content.Context} is an {@link android.app.Activity},
     * the cursor returned by the content provider will be automatically managed. Otherwise,
     * you are responsible for managing the cursor yourself.&lt;/p&gt;
     * 
     * @param context The context to load the XML resource from.
     * @param id The identifier of the XML resource declaring the adapter.
     * @param parameters Optional parameters to pass to the adapter.
     *  
     * @return An adapter instance.
     * 
     * @see #loadCursorAdapter(android.content.Context, int, android.database.Cursor, Object[])
     * @see #loadCursorAdapter(android.content.Context, int, String, Object[])
     */
    public static BaseAdapter loadAdapter(Context context, int id, Object... parameters) {
        final BaseAdapter adapter = loadAdapter(context, id, null, parameters);
        if (adapter instanceof ManagedAdapter) {
            ((ManagedAdapter) adapter).load();
        }
        return adapter;
    }

    /**
     * Loads an adapter from the specified XML resource. The optional assertName can
     * be used to exit early if the adapter defined in the XML resource is not of the
     * expected type.
     * 
     * @param context The context to associate with the adapter.
     * @param id The resource id of the XML document defining the adapter.
     * @param assertName The mandatory name of the adapter in the XML document.
     *        Ignored if null.
     * @param parameters Optional parameters passed to the adapter.
     * 
     * @return An instance of {@link android.widget.BaseAdapter}.
     */
    private static BaseAdapter loadAdapter(Context context, int id, String assertName,
            Object... parameters) {

        XmlResourceParser parser = null;
        try {
            parser = context.getResources().getXml(id);
            return createAdapterFromXml(context, parser, Xml.asAttributeSet(parser),
                    id, parameters, assertName);
        } catch (XmlPullParserException ex) {
            Resources.NotFoundException rnf = new Resources.NotFoundException(
                    "Can't load adapter resource ID " +
                    context.getResources().getResourceEntryName(id));
            rnf.initCause(ex);
            throw rnf;
        } catch (IOException ex) {
            Resources.NotFoundException rnf = new Resources.NotFoundException(
                    "Can't load adapter resource ID " +
                    context.getResources().getResourceEntryName(id));
            rnf.initCause(ex);
            throw rnf;
        } finally {
            if (parser != null) parser.close();
        }
    }

    /**
     * Generates an adapter using the specified XML parser. This method is responsible
     * for choosing the type of the adapter to create based on the content of the
     * XML parser.
     * 
     * This method will generate an {@link IllegalArgumentException} if
     * &lt;code&gt;assertName&lt;/code&gt; is not null and does not match the root tag of the XML
     * document.
     */
    private static BaseAdapter createAdapterFromXml(Context c,
            XmlPullParser parser, AttributeSet attrs, int id, Object[] parameters,
            String assertName) throws XmlPullParserException, IOException {

        BaseAdapter adapter = null;

        // Make sure we are on a start tag.
        int type;
        int depth = parser.getDepth();

        while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp;
                type != XmlPullParser.END_DOCUMENT) {

            if (type != XmlPullParser.START_TAG) {
                continue;
            }

            String name = parser.getName();
            if (assertName != null &amp;&amp; !assertName.equals(name)) {
                throw new IllegalArgumentException("The adapter defined in " +
                        c.getResources().getResourceEntryName(id) + " must be a &lt;" +
                        assertName + " /&gt;");
            }

            if (ADAPTER_CURSOR.equals(name)) {
                adapter = createCursorAdapter(c, parser, attrs, id, parameters);
            } else {
                throw new IllegalArgumentException("Unknown adapter name " + parser.getName() +
                        " in " + c.getResources().getResourceEntryName(id));
            }
        }

        return adapter;

    }

    /**
     * Creates an XmlCursorAdapter using an XmlCursorAdapterParser.
     */
    private static XmlCursorAdapter createCursorAdapter(Context c, XmlPullParser parser,
            AttributeSet attrs, int id, Object[] parameters)
            throws IOException, XmlPullParserException {

        return new XmlCursorAdapterParser(c, parser, attrs, id).parse(parameters);
    }

    /**
     * Parser that can generate XmlCursorAdapter instances. This parser is responsible for
     * handling all the attributes and child nodes for a &amp;lt;cursor-adapter /&amp;gt;.
     */
    private static class XmlCursorAdapterParser {
        private static final String ADAPTER_CURSOR_BIND = "bind";
        private static final String ADAPTER_CURSOR_SELECT = "select";
        private static final String ADAPTER_CURSOR_AS_STRING = "string";
        private static final String ADAPTER_CURSOR_AS_IMAGE = "image";
        private static final String ADAPTER_CURSOR_AS_TAG = "tag";
        private static final String ADAPTER_CURSOR_AS_IMAGE_URI = "image-uri";
        private static final String ADAPTER_CURSOR_AS_DRAWABLE = "drawable";
        private static final String ADAPTER_CURSOR_MAP = "map";
        private static final String ADAPTER_CURSOR_TRANSFORM = "transform";

        private final Context mContext;
        private final XmlPullParser mParser;
        private final AttributeSet mAttrs;
        private final int mId;

        private final HashMap&lt;String, CursorBinder&gt; mBinders;
        private final ArrayList&lt;String&gt; mFrom;
        private final ArrayList&lt;Integer&gt; mTo;
        private final CursorTransformation mIdentity;
        private final Resources mResources;

        public XmlCursorAdapterParser(Context c, XmlPullParser parser, AttributeSet attrs, int id) {
            mContext = c;
            mParser = parser;
            mAttrs = attrs;
            mId = id;

            mResources = mContext.getResources();
            mBinders = new HashMap&lt;String, CursorBinder&gt;();
            mFrom = new ArrayList&lt;String&gt;();
            mTo = new ArrayList&lt;Integer&gt;();
            mIdentity = new IdentityTransformation(mContext);
        }

        public XmlCursorAdapter parse(Object[] parameters)
               throws IOException, XmlPullParserException {

            Resources resources = mResources;
            TypedArray a = resources.obtainAttributes(mAttrs, R.styleable.CursorAdapter);

            String uri = a.getString(R.styleable.CursorAdapter_uri);
            String selection = a.getString(R.styleable.CursorAdapter_selection);
            String sortOrder = a.getString(R.styleable.CursorAdapter_sortOrder);
            int layout = a.getResourceId(R.styleable.CursorAdapter_layout, 0);
            if (layout == 0) {
                throw new IllegalArgumentException("The layout specified in " +
                        resources.getResourceEntryName(mId) + " does not exist");
            }

            a.recycle();

            XmlPullParser parser = mParser;
            int type;
            int depth = parser.getDepth();

            while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp;
                    type != XmlPullParser.END_DOCUMENT) {

                if (type != XmlPullParser.START_TAG) {
                    continue;
                }

                String name = parser.getName();

                if (ADAPTER_CURSOR_BIND.equals(name)) {
                    parseBindTag();
                } else if (ADAPTER_CURSOR_SELECT.equals(name)) {
                    parseSelectTag();
                } else {
                    throw new RuntimeException("Unknown tag name " + parser.getName() + " in " +
                            resources.getResourceEntryName(mId));
                }
            }

            String[] fromArray = mFrom.toArray(new String[mFrom.size()]);
            int[] toArray = new int[mTo.size()];
            for (int i = 0; i &lt; toArray.length; i++) {
                toArray[i] = mTo.get(i);
            }

            String[] selectionArgs = null;
            if (parameters != null) {
                selectionArgs = new String[parameters.length];
                for (int i = 0; i &lt; selectionArgs.length; i++) {
                    selectionArgs[i] = (String) parameters[i];
                }
            }

            return new XmlCursorAdapter(mContext, layout, uri, fromArray, toArray, selection,
                    selectionArgs, sortOrder, mBinders);
        }

        private void parseSelectTag() {
            TypedArray a = mResources.obtainAttributes(mAttrs,
                    R.styleable.CursorAdapter_SelectItem);

            String fromName = a.getString(R.styleable.CursorAdapter_SelectItem_column);
            if (fromName == null) {
                throw new IllegalArgumentException("A select item in " +
                        mResources.getResourceEntryName(mId) +
                        " does not have a 'column' attribute");
            }

            a.recycle();

            mFrom.add(fromName);
            mTo.add(View.NO_ID);
        }

        private void parseBindTag() throws IOException, XmlPullParserException {
            Resources resources = mResources;
            TypedArray a = resources.obtainAttributes(mAttrs,
                    R.styleable.CursorAdapter_BindItem);

            String fromName = a.getString(R.styleable.CursorAdapter_BindItem_from);
            if (fromName == null) {
                throw new IllegalArgumentException("A bind item in " +
                        resources.getResourceEntryName(mId) + " does not have a 'from' attribute");
            }

            int toName = a.getResourceId(R.styleable.CursorAdapter_BindItem_to, 0);
            if (toName == 0) {
                throw new IllegalArgumentException("A bind item in " +
                        resources.getResourceEntryName(mId) + " does not have a 'to' attribute");
            }

            String asType = a.getString(R.styleable.CursorAdapter_BindItem_as);
            if (asType == null) {
                throw new IllegalArgumentException("A bind item in " +
                        resources.getResourceEntryName(mId) + " does not have an 'as' attribute");
            }

            mFrom.add(fromName);
            mTo.add(toName);
            mBinders.put(fromName, findBinder(asType));

            a.recycle();
        }

        private CursorBinder findBinder(String type) throws IOException, XmlPullParserException {
            final XmlPullParser parser = mParser;
            final Context context = mContext;
            CursorTransformation transformation = mIdentity;

            int tagType;
            int depth = parser.getDepth();

            final boolean isDrawable = ADAPTER_CURSOR_AS_DRAWABLE.equals(type);

            while (((tagType = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth)
                    &amp;&amp; tagType != XmlPullParser.END_DOCUMENT) {

                if (tagType != XmlPullParser.START_TAG) {
                    continue;
                }

                String name = parser.getName();

                if (ADAPTER_CURSOR_TRANSFORM.equals(name)) {
                    transformation = findTransformation();
                } else if (ADAPTER_CURSOR_MAP.equals(name)) {
                    if (!(transformation instanceof MapTransformation)) {
                        transformation = new MapTransformation(context);
                    }
                    findMap(((MapTransformation) transformation), isDrawable);
                } else {
                    throw new RuntimeException("Unknown tag name " + parser.getName() + " in " +
                            context.getResources().getResourceEntryName(mId));
                }
            }

            if (ADAPTER_CURSOR_AS_STRING.equals(type)) {
                return new StringBinder(context, transformation);
            } else if (ADAPTER_CURSOR_AS_TAG.equals(type)) {
                return new TagBinder(context, transformation);
            } else if (ADAPTER_CURSOR_AS_IMAGE.equals(type)) {
                return new ImageBinder(context, transformation);
            } else if (ADAPTER_CURSOR_AS_IMAGE_URI.equals(type)) {
                return new ImageUriBinder(context, transformation);
            } else if (isDrawable) {
                return new DrawableBinder(context, transformation);
            } else {
                return createBinder(type, transformation);
            }
        }

        private CursorBinder createBinder(String type, CursorTransformation transformation) {
            if (mContext.isRestricted()) return null;

            try {
                final Class&lt;?&gt; klass = Class.forName(type, true, mContext.getClassLoader());
                if (CursorBinder.class.isAssignableFrom(klass)) {
                    final Constructor&lt;?&gt; c = klass.getDeclaredConstructor(
                            Context.class, CursorTransformation.class);
                    return (CursorBinder) c.newInstance(mContext, transformation);
                }
            } catch (ClassNotFoundException e) {
                throw new IllegalArgumentException("Cannot instanciate binder type in " +
                        mContext.getResources().getResourceEntryName(mId) + ": " + type, e);
            } catch (NoSuchMethodException e) {
                throw new IllegalArgumentException("Cannot instanciate binder type in " +
                        mContext.getResources().getResourceEntryName(mId) + ": " + type, e);
            } catch (InvocationTargetException e) {
                throw new IllegalArgumentException("Cannot instanciate binder type in " +
                        mContext.getResources().getResourceEntryName(mId) + ": " + type, e);
            } catch (InstantiationException e) {
                throw new IllegalArgumentException("Cannot instanciate binder type in " +
                        mContext.getResources().getResourceEntryName(mId) + ": " + type, e);
            } catch (IllegalAccessException e) {
                throw new IllegalArgumentException("Cannot instanciate binder type in " +
                        mContext.getResources().getResourceEntryName(mId) + ": " + type, e);
            }

            return null;
        }

        private void findMap(MapTransformation transformation, boolean drawable) {
            Resources resources = mResources;

            TypedArray a = resources.obtainAttributes(mAttrs,
                    R.styleable.CursorAdapter_MapItem);

            String from = a.getString(R.styleable.CursorAdapter_MapItem_fromValue);
            if (from == null) {
                throw new IllegalArgumentException("A map item in " +
                        resources.getResourceEntryName(mId) +
                        " does not have a 'fromValue' attribute");
            }

            if (!drawable) {
                String to = a.getString(R.styleable.CursorAdapter_MapItem_toValue);
                if (to == null) {
                    throw new IllegalArgumentException("A map item in " +
                            resources.getResourceEntryName(mId) +
                            " does not have a 'toValue' attribute");
                }
                transformation.addStringMapping(from, to);
            } else {
                int to = a.getResourceId(R.styleable.CursorAdapter_MapItem_toValue, 0);
                if (to == 0) {
                    throw new IllegalArgumentException("A map item in " +
                            resources.getResourceEntryName(mId) +
                            " does not have a 'toValue' attribute");
                }
                transformation.addResourceMapping(from, to);
            }

            a.recycle();
        }

        private CursorTransformation findTransformation() {
            Resources resources = mResources;
            CursorTransformation transformation = null;
            TypedArray a = resources.obtainAttributes(mAttrs,
                    R.styleable.CursorAdapter_TransformItem);

            String className = a.getString(R.styleable.CursorAdapter_TransformItem_withClass);
            if (className == null) {
                String expression = a.getString(
                        R.styleable.CursorAdapter_TransformItem_withExpression);
                transformation = createExpressionTransformation(expression);
            } else if (!mContext.isRestricted()) {
                try {
                    final Class&lt;?&gt; klas = Class.forName(className, true, mContext.getClassLoader());
                    if (CursorTransformation.class.isAssignableFrom(klas)) {
                        final Constructor&lt;?&gt; c = klas.getDeclaredConstructor(Context.class);
                        transformation = (CursorTransformation) c.newInstance(mContext);
                    }
                } catch (ClassNotFoundException e) {
                    throw new IllegalArgumentException("Cannot instanciate transform type in " +
                           mContext.getResources().getResourceEntryName(mId) + ": " + className, e);
                } catch (NoSuchMethodException e) {
                    throw new IllegalArgumentException("Cannot instanciate transform type in " +
                           mContext.getResources().getResourceEntryName(mId) + ": " + className, e);
                } catch (InvocationTargetException e) {
                    throw new IllegalArgumentException("Cannot instanciate transform type in " +
                           mContext.getResources().getResourceEntryName(mId) + ": " + className, e);
                } catch (InstantiationException e) {
                    throw new IllegalArgumentException("Cannot instanciate transform type in " +
                           mContext.getResources().getResourceEntryName(mId) + ": " + className, e);
                } catch (IllegalAccessException e) {
                    throw new IllegalArgumentException("Cannot instanciate transform type in " +
                           mContext.getResources().getResourceEntryName(mId) + ": " + className, e);
                }
            }

            a.recycle();

            if (transformation == null) {
                throw new IllegalArgumentException("A transform item in " +
                    resources.getResourceEntryName(mId) + " must have a 'withClass' or " +
                    "'withExpression' attribute");
            }

            return transformation;
        }

        private CursorTransformation createExpressionTransformation(String expression) {
            return new ExpressionTransformation(mContext, expression);
        }
    }

    /**
     * Interface used by adapters that require to be loaded after creation.
     */
    private static interface ManagedAdapter {
        /**
         * Loads the content of the adapter, asynchronously.
         */
        void load();
    }

    /**
     * Implementation of a Cursor adapter defined in XML. This class is a thin wrapper
     * of a SimpleCursorAdapter. The main difference is the ability to handle CursorBinders.
     */
    private static class XmlCursorAdapter extends SimpleCursorAdapter implements ManagedAdapter {
        private Context mContext;
        private String mUri;
        private final String mSelection;
        private final String[] mSelectionArgs;
        private final String mSortOrder;
        private final int[] mTo;
        private final String[] mFrom;
        private final String[] mColumns;
        private final CursorBinder[] mBinders;
        private AsyncTask&lt;Void,Void,Cursor&gt; mLoadTask;

        XmlCursorAdapter(Context context, int layout, String uri, String[] from, int[] to,
                String selection, String[] selectionArgs, String sortOrder,
                HashMap&lt;String, CursorBinder&gt; binders) {

            super(context, layout, null, from, to);
            mContext = context;
            mUri = uri;
            mFrom = from;
            mTo = to;
            mSelection = selection;
            mSelectionArgs = selectionArgs;
            mSortOrder = sortOrder;
            mColumns = new String[from.length + 1];
            // This is mandatory in CursorAdapter
            mColumns[0] = "_id";
            System.arraycopy(from, 0, mColumns, 1, from.length);

            CursorBinder basic = new StringBinder(context, new IdentityTransformation(context));
            final int count = from.length;
            mBinders = new CursorBinder[count];

            for (int i = 0; i &lt; count; i++) {
                CursorBinder binder = binders.get(from[i]);
                if (binder == null) binder = basic;
                mBinders[i] = binder;
            }
        }

        @Override
        public void bindView(View view, Context context, Cursor cursor) {
            final int count = mTo.length;
            final int[] to = mTo;
            final CursorBinder[] binders = mBinders;

            for (int i = 0; i &lt; count; i++) {
                final View v = view.findViewById(to[i]);
                if (v != null) {
                    // Not optimal, the column index could be cached
                    binders[i].bind(v, cursor, cursor.getColumnIndex(mFrom[i]));
                }
            }
        }

        public void load() {
            if (mUri != null) {
                mLoadTask = new QueryTask().execute();
            }
        }

        void setUri(String uri) {
            mUri = uri;
        }

        @Override
        public void changeCursor(Cursor c) {
            if (mLoadTask != null &amp;&amp; mLoadTask.getStatus() != QueryTask.Status.FINISHED) {
                mLoadTask.cancel(true);
                mLoadTask = null;
            }
            super.changeCursor(c);
        }

        class QueryTask extends AsyncTask&lt;Void, Void, Cursor&gt; {
            @Override
            protected Cursor doInBackground(Void... params) {
                if (mContext instanceof Activity) {
                    return ((Activity) mContext).managedQuery(
                            Uri.parse(mUri), mColumns, mSelection, mSelectionArgs, mSortOrder);
                } else {
                    return mContext.getContentResolver().query(
                            Uri.parse(mUri), mColumns, mSelection, mSelectionArgs, mSortOrder);
                }
            }

            @Override
            protected void onPostExecute(Cursor cursor) {
                if (!isCancelled()) {
                    XmlCursorAdapter.super.changeCursor(cursor);
                }
            }
        }
    }

    /**
     * Identity transformation, returns the content of the specified column as a String,
     * without performing any manipulation. This is used when no transformation is specified.
     */
    private static class IdentityTransformation extends CursorTransformation {
        public IdentityTransformation(Context context) {
            super(context);
        }

        @Override
        public String transform(Cursor cursor, int columnIndex) {
            return cursor.getString(columnIndex);
        }
    }

    /**
     * An expression transformation is a simple template based replacement utility.
     * In an expression, each segment of the form &lt;code&gt;{([^}]+)}&lt;/code&gt; is replaced
     * with the value of the column of name $1.
     */
    private static class ExpressionTransformation extends CursorTransformation {
        private final ExpressionNode mFirstNode = new ConstantExpressionNode("");
        private final StringBuilder mBuilder = new StringBuilder();

        public ExpressionTransformation(Context context, String expression) {
            super(context);

            parse(expression);
        }

        private void parse(String expression) {
            ExpressionNode node = mFirstNode;
            int segmentStart;
            int count = expression.length();

            for (int i = 0; i &lt; count; i++) {
                char c = expression.charAt(i);
                // Start a column name segment
                segmentStart = i;
                if (c == '{') {
                    while (i &lt; count &amp;&amp; (c = expression.charAt(i)) != '}') {
                        i++;
                    }
                    // We've reached the end, but the expression didn't close
                    if (c != '}') {
                        throw new IllegalStateException("The transform expression contains a " +
                                "non-closed column name: " +
                                expression.substring(segmentStart + 1, i));
                    }
                    node.next = new ColumnExpressionNode(expression.substring(segmentStart + 1, i));
                } else {
                    while (i &lt; count &amp;&amp; (c = expression.charAt(i)) != '{') {
                        i++;
                    }
                    node.next = new ConstantExpressionNode(expression.substring(segmentStart, i));
                    // Rewind if we've reached a column expression
                    if (c == '{') i--;
                }
                node = node.next;
            }
        }

        @Override
        public String transform(Cursor cursor, int columnIndex) {
            final StringBuilder builder = mBuilder;
            builder.delete(0, builder.length());

            ExpressionNode node = mFirstNode;
            // Skip the first node
            while ((node = node.next) != null) {
                builder.append(node.asString(cursor));
            }

            return builder.toString();
        }

        static abstract class ExpressionNode {
            public ExpressionNode next;

            public abstract String asString(Cursor cursor);
        }

        static class ConstantExpressionNode extends ExpressionNode {
            private final String mConstant;

            ConstantExpressionNode(String constant) {
                mConstant = constant;
            }

            @Override
            public String asString(Cursor cursor) {
                return mConstant;
            }
        }

        static class ColumnExpressionNode extends ExpressionNode {
            private final String mColumnName;
            private Cursor mSignature;
            private int mColumnIndex = -1;

            ColumnExpressionNode(String columnName) {
                mColumnName = columnName;
            }

            @Override
            public String asString(Cursor cursor) {
                if (cursor != mSignature || mColumnIndex == -1) {
                    mColumnIndex = cursor.getColumnIndex(mColumnName);
                    mSignature = cursor;
                }

                return cursor.getString(mColumnIndex);
            }
        }
    }

    /**
     * A map transformation offers a simple mapping between specified String values
     * to Strings or integers.
     */
    private static class MapTransformation extends CursorTransformation {
        private final HashMap&lt;String, String&gt; mStringMappings;
        private final HashMap&lt;String, Integer&gt; mResourceMappings;

        public MapTransformation(Context context) {
            super(context);
            mStringMappings = new HashMap&lt;String, String&gt;();
            mResourceMappings = new HashMap&lt;String, Integer&gt;();
        }

        void addStringMapping(String from, String to) {
            mStringMappings.put(from, to);
        }

        void addResourceMapping(String from, int to) {
            mResourceMappings.put(from, to);
        }

        @Override
        public String transform(Cursor cursor, int columnIndex) {
            final String value = cursor.getString(columnIndex);
            final String transformed = mStringMappings.get(value);
            return transformed == null ? value : transformed;
        }

        @Override
        public int transformToResource(Cursor cursor, int columnIndex) {
            final String value = cursor.getString(columnIndex);
            final Integer transformed = mResourceMappings.get(value);
            try {
                return transformed == null ? Integer.parseInt(value) : transformed;
            } catch (NumberFormatException e) {
                return 0;
            }
        }
    }

    /**
     * Binds a String to a TextView.
     */
    private static class StringBinder extends CursorBinder {
        public StringBinder(Context context, CursorTransformation transformation) {
            super(context, transformation);
        }

        @Override
        public boolean bind(View view, Cursor cursor, int columnIndex) {
            if (view instanceof TextView) {
                final String text = mTransformation.transform(cursor, columnIndex);
                ((TextView) view).setText(text);
                return true;
            }
            return false;
        }
    }

    /**
     * Binds an image blob to an ImageView.
     */
    private static class ImageBinder extends CursorBinder {
        public ImageBinder(Context context, CursorTransformation transformation) {
            super(context, transformation);
        }

        @Override
        public boolean bind(View view, Cursor cursor, int columnIndex) {
            if (view instanceof ImageView) {
                final byte[] data = cursor.getBlob(columnIndex);
                ((ImageView) view).setImageBitmap(BitmapFactory.decodeByteArray(data, 0,
                        data.length));
                return true;
            }
            return false;
        }
    }

    private static class TagBinder extends CursorBinder {
        public TagBinder(Context context, CursorTransformation transformation) {
            super(context, transformation);
        }

        @Override
        public boolean bind(View view, Cursor cursor, int columnIndex) {
            final String text = mTransformation.transform(cursor, columnIndex);
            view.setTag(text);
            return true;
        }
    }

    /**
     * Binds an image URI to an ImageView.
     */
    private static class ImageUriBinder extends CursorBinder {
        public ImageUriBinder(Context context, CursorTransformation transformation) {
            super(context, transformation);
        }

        @Override
        public boolean bind(View view, Cursor cursor, int columnIndex) {
            if (view instanceof ImageView) {
                ((ImageView) view).setImageURI(Uri.parse(
                        mTransformation.transform(cursor, columnIndex)));
                return true;
            }
            return false;
        }
    }

    /**
     * Binds a drawable resource identifier to an ImageView.
     */
    private static class DrawableBinder extends CursorBinder {
        public DrawableBinder(Context context, CursorTransformation transformation) {
            super(context, transformation);
        }

        @Override
        public boolean bind(View view, Cursor cursor, int columnIndex) {
            if (view instanceof ImageView) {
                final int resource = mTransformation.transformToResource(cursor, columnIndex);
                if (resource == 0) return false;

                ((ImageView) view).setImageResource(resource);
                return true;
            }
            return false;
        }
    }
}</pre>
<!-- end file contents -->

<div id="footer" class="wrap" >
        

  <div id="copyright">
    
  除非有特别提醒，本文档受 
  <a href="http://creativecommons.org/licenses/by/2.5/">
  Creative Commons Attribution 2.5</a>法律条款保护。详细细节和限制，请见 
  <a href="../../../../../../../../license.html">Content 
  License</a>。
  </div>


  <div id="footerlinks">
    
  <p>
    <a href="../../../../../../../../about/index.html">About Android</a>&nbsp;&nbsp;|&nbsp;
    <a href="../../../../../../../../legal.html">Legal</a>&nbsp;&nbsp;|&nbsp;
    <a href="../../../../../../../../support.html">Support</a>
  </p>
  </div>

</div> <!-- end footer -->
</div><!-- end jd-content -->
</div> <!-- end doc-content -->

</div> <!-- end body-content --> 




<!-- Grid - for dev 
<script type="text/javascript">

window.gOverride = {
		gColor: '#FF0000',
		pColor: '#EEEEEE',
		gOpacity: 0.10,
		pOpacity: 0.40,
		pHeight: 16,
		pOffset: 2,
		gColumns:16,
		gEnabled:false,
		pEnabled:false
	}
</script>
	
<link href="../../../../../../../../assets/js/grid/960.gridder.css" rel="stylesheet" type="text/css">
<script src="../../../../../../../../assets/js/grid/960.gridder.js" type="text/javascript"></script>
-->





<script type="text/javascript">
init(); /* initialize android-developer-docs.js */
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>

<script type="text/javascript">
  var pageTracker = _gat._getTracker("UA-5831155-1");
  pageTracker._trackPageview();
</script>



</body>
</html>
